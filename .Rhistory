# Call the network topology analysis function
sft = pickSoftThreshold(for_modules, powerVector = powers, verbose = 5)
# Plot the results:
par(mar = c(4, 4, .1, .1))
sizeGrWindow(9, 5)
par(mfrow = c(1,2));
cex1 = 0.9;
# Scale-free topology fit index as a function of the soft-thresholding power
plot(sft$fitIndices[,1], -sign(sft$fitIndices[,3])*sft$fitIndices[,2],
xlab="Soft Threshold (power)",ylab="Scale Free Topology Model Fit,signed R^2",type="n",
main = paste("Scale independence"));
text(sft$fitIndices[,1], -sign(sft$fitIndices[,3])*sft$fitIndices[,2],
labels=powers,cex=cex1,col="red");
# this line corresponds to using an R^2 cut-off of h
abline(h=0.80,col="red")
# Mean connectivity as a function of the soft-thresholding power
plot(sft$fitIndices[,1], sft$fitIndices[,5],
xlab="Soft Threshold (power)",ylab="Mean Connectivity", type="n",
main = paste("Mean connectivity"))
text(sft$fitIndices[,1], sft$fitIndices[,5], labels=powers, cex=cex1,col="red")
sft$fitIndices[,5]
sft
sft$fitIndices[,5]
data.frame(
Power = sft$fitIndices[,1],
sft_signedR2 = -sign(sft$fitIndices[,3])*sft$fitIndices[,2],
mean.k = sft$fitIndices[,5])
# this line corresponds to using an R^2 cut-off of h
# Mean connectivity as a function of the soft-thresholding power
sft_df <- data.frame(
Power = sft$fitIndices[,1],
sft_signedR2 = -sign(sft$fitIndices[,3])*sft$fitIndices[,2],
mean.k = sft$fitIndices[,5])
ggplot(data = sft_df, aes(x = Power, y = sft_signedR2))
ggplot(data = sft_df, aes(x = Power, y = sft_signedR2), xlab="Soft Threshold (power)",ylab="Scale Free Topology Model Fit,signed R^2",type="n", main = "Scale independence")
plot(sft$fitIndices[,1], -sign(sft$fitIndices[,3])*sft$fitIndices[,2],
xlab="Soft Threshold (power)",ylab="Scale Free Topology Model Fit,signed R^2",type="n",
main = paste("Scale independence")));
plot(sft$fitIndices[,1], -sign(sft$fitIndices[,3])*sft$fitIndices[,2],
xlab="Soft Threshold (power)",ylab="Scale Free Topology Model Fit,signed R^2",type="n",
main = paste("Scale independence"));
plot(sft$fitIndices[,1], -sign(sft$fitIndices[,3])*sft$fitIndices[,2],
xlab="Soft Threshold (power)",ylab="Scale Free Topology Model Fit,signed R^2",type="n",
main = paste("Scale independence"));
text(sft$fitIndices[,1], -sign(sft$fitIndices[,3])*sft$fitIndices[,2],
labels=powers,cex=cex1,col="red");
plot(sft$fitIndices[,1], -sign(sft$fitIndices[,3])*sft$fitIndices[,2],
xlab="Soft Threshold (power)",ylab="Scale Free Topology Model Fit,signed R^2",type="n",
main = paste("Scale independence"));
text(sft$fitIndices[,1], -sign(sft$fitIndices[,3])*sft$fitIndices[,2],
labels=powers,cex=cex1,col="red");
abline(h=0.80,col="red")
plot(sft$fitIndices[,1], sft$fitIndices[,5],
xlab="Soft Threshold (power)",ylab="Mean Connectivity", type="n",
main = paste("Mean connectivity"))
text(sft$fitIndices[,1], sft$fitIndices[,5], labels=powers, cex=cex1,col="red")
sizeGrWindow(9, 5)
par(mfrow = c(1,2));
cex1 = 0.9;
plot(sft$fitIndices[,1], -sign(sft$fitIndices[,3])*sft$fitIndices[,2],
xlab="Soft Threshold (power)",ylab="Scale Free Topology Model Fit,signed R^2",type="n",
main = paste("Scale independence"));
text(sft$fitIndices[,1], -sign(sft$fitIndices[,3])*sft$fitIndices[,2],
labels=powers,cex=cex1,col="red");
abline(h=0.80,col="red")
plot(sft$fitIndices[,1], sft$fitIndices[,5],
xlab="Soft Threshold (power)",ylab="Mean Connectivity", type="n",
main = paste("Mean connectivity"))
text(sft$fitIndices[,1], sft$fitIndices[,5], labels=powers, cex=cex1,col="red")
plot(sft$fitIndices[,1], -sign(sft$fitIndices[,3])*sft$fitIndices[,2],
xlab="Soft Threshold (power)",ylab="Scale Free Topology Model Fit,signed R^2",type="n",
main = paste("Scale independence"));
ggplot(data = sft_df, aes(x = Power, y = sft_signedR2), xlab="Soft Threshold (power)",ylab="Scale Free Topology Model Fit,signed R^2",type="n", main = "Scale independence")
ggplot(data = sft_df, aes(x = Power, y = sft_signedR2),
xlab="Soft Threshold (power)",
ylab="Scale Free Topology Model Fit,signed R^2",
main = "Scale independence")
ggplot(data = sft_df, aes(x = Power, y = sft_signedR2),
xlab="Soft Threshold (power)",
ylab="Scale Free Topology Model Fit,signed R^2",
main = "Scale independence") +
theme_classic()
ggplot(data = sft_df, aes(x = Power, y = sft_signedR2)) +
xlab("Soft Threshold (power)") +
ylab=("Scale Free Topology Model Fit,signed R^2") +
main = ("Scale independence") +
theme_classic()
ggplot(data = sft_df, aes(x = Power, y = sft_signedR2)) +
xlab("Soft Threshold (power)") +
ylab=("Scale Free Topology Model Fit,signed R^2") +
ggtitle("Scale independence") +
theme_classic()
ggplot(data = sft_df, aes(x = Power, y = sft_signedR2)) +
xlab("Soft Threshold (power)") +
ylab("Scale Free Topology Model Fit,signed R^2") +
ggtitle("Scale independence") +
theme_classic()
ggplot(data = sft_df, aes(x = Power, y = sft_signedR2)) +
xlab("Soft Threshold (power)") +
ylab("Scale Free Topology Model Fit,signed R^2") +
ggtitle("Scale independence") +
theme_classic()+
geom_text(size=6)
ggplot(data = sft_df, aes(x = Power, y = sft_signedR2)) +
xlab("Soft Threshold (power)") +
ylab("Scale Free Topology Model Fit,signed R^2") +
ggtitle("Scale independence") +
theme_classic() +
geom_point() +
geom_text(size=6)
ggplot(data = sft_df, aes(x = Power, y = sft_signedR2)) +
xlab("Soft Threshold (power)") +
ylab("Scale Free Topology Model Fit,signed R^2") +
ggtitle("Scale independence") +
theme_classic() +
geom_point()
ggplot(data = sft_df, aes(x = Power, y = sft_signedR2)) +
xlab("Soft Threshold (power)") +
ylab("Scale Free Topology Model Fit,signed R^2") +
ggtitle("Scale independence") +
theme_classic() +
geom_point() +
geom_text(data = sft_df, aes(x = Power, y = sft_signedR2), size=6)
sft_df
ggplot(data = sft_df, aes(x = Power, y = sft_signedR2, label = Power)) +
xlab("Soft Threshold (power)") +
ylab("Scale Free Topology Model Fit,signed R^2") +
ggtitle("Scale independence") +
theme_classic() +
geom_point() +
geom_text(data = sft_df, aes(x = Power, y = sft_signedR2), size=6)
ggplot(data = sft_df, aes(x = Power, y = sft_signedR2, label = Power)) +
xlab("Soft Threshold (power)") +
ylab("Scale Free Topology Model Fit,signed R^2") +
ggtitle("Scale independence") +
theme_classic() +
geom_text(data = sft_df, aes(x = Power, y = sft_signedR2), size=6)
# Scale-free topology fit index as a function of the soft-thresholding power
ggplot(data = sft_df, aes(x = Power, y = sft_signedR2, label = Power)) +
xlab("Soft Threshold (power)") +
ylab("Scale Free Topology Model Fit,signed R^2") +
ggtitle("Scale independence") +
theme_classic() +
geom_text(data = sft_df, aes(x = Power, y = sft_signedR2), size=6) +
geom_hline(yintercept = 0.8, col="red")
sft_df
# Mean connectivity as a function of the soft-thresholding power
ggplot(data = sft_df, aes(x = Power, y = mean.k, label = mean.k)) +
xlab("Soft Threshold (power)") +
ylab("Mean Connectivity") +
ggtitle("Mean Connectivity") +
theme_classic() +
geom_text(data = sft_df, aes(x = Power, y = powers), size=6)
plot(sft$fitIndices[,1], sft$fitIndices[,5],
xlab="Soft Threshold (power)",ylab="Mean Connectivity", type="n",
main = paste("Mean connectivity"))
plot(sft$fitIndices[,1], sft$fitIndices[,5],
xlab="Soft Threshold (power)",ylab="Mean Connectivity", type="n",
main = paste("Mean connectivity"))
text(sft$fitIndices[,1], sft$fitIndices[,5], labels=powers, cex=cex1,col="red")
sft$fitIndices[,5]
# Mean connectivity as a function of the soft-thresholding power
ggplot(data = sft_df, aes(x = Power, y = mean.k, label = powers)) +
xlab("Soft Threshold (power)") +
ylab("Mean Connectivity") +
ggtitle("Mean Connectivity") +
theme_classic() +
geom_text(data = sft_df, aes(x = Power, y = mean.k), size=6)
# Plot the results:
# this line corresponds to using an R^2 cut-off of h
# Mean connectivity as a function of the soft-thresholding power
sft_df <- data.frame(
Power = sft$fitIndices[,1],
sft_signedR2 = -sign(sft$fitIndices[,3])*sft$fitIndices[,2],
mean.k = sft$fitIndices[,5])
# plot it:
sizeGrWindow(9, 5)
par(mfrow = c(1,2));
cex1 = 0.9
# Scale-free topology fit index as a function of the soft-thresholding power
ggplot(data = sft_df, aes(x = Power, y = sft_signedR2, label = Power)) +
xlab("Soft Threshold (power)") +
ylab("Scale Free Topology Model Fit,signed R^2") +
ggtitle("Scale independence") +
theme_classic() +
geom_text(data = sft_df, aes(x = Power, y = sft_signedR2), size=6) +
geom_hline(yintercept = 0.8, col="red") # this line corresponds to using an R^2 cut-off of h
# Mean connectivity as a function of the soft-thresholding power
ggplot(data = sft_df, aes(x = Power, y = mean.k, label = powers)) +
xlab("Soft Threshold (power)") +
ylab("Mean Connectivity") +
ggtitle("Mean Connectivity") +
theme_classic() +
geom_text(data = sft_df, aes(x = Power, y = mean.k), size=6)
# Plot the results:
# this line corresponds to using an R^2 cut-off of h
# Mean connectivity as a function of the soft-thresholding power
sft_df <- data.frame(
Power = sft$fitIndices[,1],
sft_signedR2 = -sign(sft$fitIndices[,3])*sft$fitIndices[,2],
mean.k = sft$fitIndices[,5])
# plot it:
sizeGrWindow(9, 5)
par(mfrow = c(1,2));
cex1 = 0.9
# Scale-free topology fit index as a function of the soft-thresholding power
ggplot(data = sft_df, aes(x = Power, y = sft_signedR2, label = Power)) +
xlab("Soft Threshold (power)") +
ylab("Scale Free Topology Model Fit,signed R^2") +
ggtitle("Scale independence") +
theme_classic() +
geom_text(data = sft_df, aes(x = Power, y = sft_signedR2), size=6) +
geom_hline(yintercept = 0.8, col="red") # this line corresponds to using an R^2 cut-off of h
# Mean connectivity as a function of the soft-thresholding power
ggplot(data = sft_df, aes(x = Power, y = mean.k, label = powers)) +
xlab("Soft Threshold (power)") +
ylab("Mean Connectivity") +
ggtitle("Mean Connectivity") +
theme_classic() +
geom_text(data = sft_df, aes(x = Power, y = mean.k), size=6)
# Plot the results:
# this line corresponds to using an R^2 cut-off of h
# Mean connectivity as a function of the soft-thresholding power
sft_df <- data.frame(
Power = sft$fitIndices[,1],
sft_signedR2 = -sign(sft$fitIndices[,3])*sft$fitIndices[,2],
mean.k = sft$fitIndices[,5])
# Scale-free topology fit index as a function of the soft-thresholding power
pSI <- ggplot(data = sft_df, aes(x = Power, y = sft_signedR2, label = Power)) +
xlab("Soft Threshold (power)") +
ylab("Scale Free Topology Model Fit,signed R^2") +
ggtitle("Scale independence") +
theme_classic() +
geom_text(data = sft_df, aes(x = Power, y = sft_signedR2), size=6) +
geom_hline(yintercept = 0.8, col="red") # this line corresponds to using an R^2 cut-off of h
# Mean connectivity as a function of the soft-thresholding power
pMC <- ggplot(data = sft_df, aes(x = Power, y = mean.k, label = powers)) +
xlab("Soft Threshold (power)") +
ylab("Mean Connectivity") +
ggtitle("Mean Connectivity") +
theme_classic() +
geom_text(data = sft_df, aes(x = Power, y = mean.k), size=6)
# plot it:
sizeGrWindow(9, 5)
par(mfrow = c(1,2));
cex1 = 0.9
pSI
pMC
# Plot the results:
# this line corresponds to using an R^2 cut-off of h
# Mean connectivity as a function of the soft-thresholding power
sft_df <- data.frame(
Power = sft$fitIndices[,1],
sft_signedR2 = -sign(sft$fitIndices[,3])*sft$fitIndices[,2],
mean.k = sft$fitIndices[,5])
# Scale-free topology fit index as a function of the soft-thresholding power
pSI <- ggplot(data = sft_df, aes(x = Power, y = sft_signedR2, label = Power)) +
xlab("Soft Threshold (power)") +
ylab("Scale Free Topology Model Fit,signed R^2") +
ggtitle("Scale independence") +
theme_classic() +
geom_text(data = sft_df, aes(x = Power, y = sft_signedR2), size=6) +
geom_hline(yintercept = 0.8, col="red") # this line corresponds to using an R^2 cut-off of h
# Mean connectivity as a function of the soft-thresholding power
pMC <- ggplot(data = sft_df, aes(x = Power, y = mean.k, label = powers)) +
xlab("Soft Threshold (power)") +
ylab("Mean Connectivity") +
ggtitle("Mean Connectivity") +
theme_classic() +
geom_text(data = sft_df, aes(x = Power, y = mean.k), size=6)
# plot it:
par(mar = c(4, 4, .1, .1))
pSI
pMC
# plot the two PCA plots side by side:
par(mar = c(4, 4, .1, .1))
p71
p66
# when we remove them and repeat the PCA (Fig S2b), the library scatter more homogeneously.
ggplot(data = sft_df, aes(x = Power, y = mean.k, label = powers)) +
xlab("Soft Threshold (power)") +
ylab("Mean Connectivity") +
ggtitle("Mean Connectivity") +
theme_classic() +
theme(text = element_text(size=20)) +
geom_text(data = sft_df, aes(x = Power, y = mean.k), size=6)
ggplot(data = sft_df, aes(x = Power, y = mean.k, label = powers)) +
xlab("Soft Threshold (power)") +
ylab("Mean Connectivity") +
ggtitle("Mean Connectivity") +
theme_classic() +
theme(text = element_text(size=16)) +
geom_text(data = sft_df, aes(x = Power, y = mean.k), size=6)
# open a graphics window
sizeGrWindow(12, 9)
# Convert labels to colors for plotting
mergedColors = labels2colors(net$colors)
# Plot the dendrogram and the module colors underneath
plotDendroAndColors(net$dendrograms[[1]], mergedColors[net$blockGenes[[1]]],
"Module colors",
dendroLabels = FALSE, hang = 0.03,
addGuide = TRUE, guideHang = 0.05)
# Display the correlation values within a heatmap plot
labeledHeatmap(Matrix = moduleTraitCor_66,
xLabels = names(viruses_load_15),
yLabels = names(MEs),
#xLabelsAngle = 90,
ySymbols = names(MEs),
colorLabels = FALSE,
colors = hcl.colors(n = 50, palette = "RdBu", alpha = NULL, rev = FALSE, fixup = TRUE),
invertColors = TRUE,
textMatrix = textMatrix,
setStdMargins = FALSE,
cex.text = 0.7,
zlim = c(-1,1),
main = paste("Varroa Module-viruses relationships"))
#  Display correlations and their adjusted p-values
textMatrix = paste(signif(moduleTraitCor_66, 2), "\n(",
signif(moduleTraitPadjust_66, 1), ")", sep = "");
dim(textMatrix) = dim(moduleTraitCor_66)
par(mar = c(6, 8.5, 3, 3));
# Display the correlation values within a heatmap plot
labeledHeatmap(Matrix = moduleTraitCor_66,
xLabels = names(viruses_load_15),
yLabels = names(MEs),
#xLabelsAngle = 90,
ySymbols = names(MEs),
colorLabels = FALSE,
colors = hcl.colors(n = 50, palette = "RdBu", alpha = NULL, rev = FALSE, fixup = TRUE),
invertColors = TRUE,
textMatrix = textMatrix,
setStdMargins = FALSE,
cex.text = 0.7,
zlim = c(-1,1),
main = paste("Varroa Module-viruses relationships"))
# For correlating varroa modules to viral load, we gonna use the table of 15 viruses saved in chunk "viral correlation", in section "viral correlation matrix", and correlated these to the varroa modules eigengenes found in the previous chunk.
# First we load the two data:
load("/Users/nuriteliash/Documents/GitHub/varroa-virus-networks/results/viruses_load_15.rds")
load(file = "/Users/nuriteliash/Documents/GitHub/varroa-virus-networks/results/Varroa_modules_networkConstruction-auto.RData")
# Define numbers of genes and samples
nGenes = ncol(for_modules);
nSamples = nrow(for_modules)
# Recalculate MEs with color labels
MEs0 = moduleEigengenes(for_modules, moduleColors)$eigengenes
MEs = orderMEs(MEs0)
# correlate the modules eigengenes (MEs) with the viral load (viruses_load_15)
moduleTraitCor = cor(MEs, viruses_load_15, use = "p");
moduleTraitPvalue = corPvalueStudent(moduleTraitCor, nSamples)
### Controlling the false discovery rate: Benjaminiâ€“Hochberg procedure ###
# using p.adjust function, for all comparisons, 15 modules and 15 viruses (m=225).
# first make the p-value matrix into a dataframe
moduleTraitPvalue_0 <- as.data.frame(moduleTraitPvalue)
# then "gather" all the p-values, so they will apear in one column
longer_Pvalue <- moduleTraitPvalue_0 %>%
rownames_to_column("module") %>%
gather("virus", "pvalue", -module)
# now calculate the p.adjust for each p-value
Padjust <- p.adjust(longer_Pvalue$pvalue, method = "fdr")
# and add the column of adjusted pvalues
Padjust <- add_column(longer_Pvalue, Padjust)
# now spread it back
moduleTraitPadjust <- Padjust %>%
dplyr::select(-pvalue) %>%
group_by(virus) %>%
pivot_wider(names_from = virus, values_from = Padjust)
moduleTraitPadjust <- column_to_rownames(moduleTraitPadjust, "module")
# before correlating, make the two dataframes into "matrices"
moduleTraitCor_66 <- as.matrix(moduleTraitCor)
moduleTraitPadjust_66 <- as.matrix(moduleTraitPadjust)
#  Display correlations and their adjusted p-values
sizeGrWindow(10,6)
textMatrix = paste(signif(moduleTraitCor_66, 2), "\n(",
signif(moduleTraitPadjust_66, 1), ")", sep = "");
dim(textMatrix) = dim(moduleTraitCor_66)
par(mar = c(6, 8.5, 3, 3));
# Display the correlation values within a heatmap plot
labeledHeatmap(Matrix = moduleTraitCor_66,
xLabels = names(viruses_load_15),
yLabels = names(MEs),
#xLabelsAngle = 90,
ySymbols = names(MEs),
colorLabels = FALSE,
colors = hcl.colors(n = 50, palette = "RdBu", alpha = NULL, rev = FALSE, fixup = TRUE),
invertColors = TRUE,
textMatrix = textMatrix,
setStdMargins = FALSE,
cex.text = 0.7,
zlim = c(-1,1),
main = paste("Varroa Module-viruses relationships"))
# save the matrices for next analyses
#save(moduleTraitCor_66,moduleTraitPadjust_66, file = "/Users/nuriteliash/Documents/GitHub/varroa-virus-networks/results/moduleTraitCor_66.RData")
moduleTraitPadjust_66
View(moduleTraitCor_66)
viruses_load  %>%
mutate(description =  factor(description, levels = new_order)) %>%
arrange(description)
# re-order the viruses, based on viral load and viral abundance (from highest, on the left, to lowest on the right), and change the names of the viruses to match their common name in the literature:
viruses_load_arranged <- viruses_load  %>%
mutate(description =  factor(description, levels = new_order)) %>%
arrange(description) %>%
mutate(across("description", str_replace, "VOV_1", "VOV-1")) %>%
mutate(across("description", str_replace, "ARV_2", "ARV-2")) %>%
mutate(across("description", str_replace, "SV", "SBV")) %>%
mutate(across("description", str_replace, "LSBV", "LSV")) %>%
mutate(across("description", str_replace, "VDV1/DWVb", "DWVb"))
viruses_load_arranged
View(viruses_load_arranged)
# now spread it back
moduleTraitPadjust <- Padjust %>%
dplyr::select(-pvalue) %>%
group_by(virus) %>%
pivot_wider(names_from = virus, values_from = Padjust)
View(moduleTraitPadjust)
moduleTraitCor %>%
rename("VOV_1" = "VOV-1", "ARV_2"= "ARV-2", "SV"= "SBV", "LSBV"= "LSV", "VDV1/DWVb"="DWVb") %>%
as.matrix(moduleTraitCor)
moduleTraitCor
moduleTraitPadjust <- Padjust %>%
dplyr::select(-pvalue) %>%
group_by(virus) %>%
pivot_wider(names_from = virus, values_from = Padjust)
View(moduleTraitPadjust)
moduleTraitCor
moduleTraitCor %>%
rename("VOV_1" = "VOV-1", "ARV_2"= "ARV-2", "SV"= "SBV", "LSBV"= "LSV", "VDV1/DWVb"="DWVb")
moduleTraitCor %>%
dplyr::rename("VOV_1" = "VOV-1", "ARV_2"= "ARV-2", "SV"= "SBV", "LSBV"= "LSV", "VDV1/DWVb"="DWVb")
class(moduleTraitCor)
# correlate the modules eigengenes (MEs) with the viral load (viruses_load_15)
moduleTraitCor = cor(MEs, viruses_load_15, use = "p");
moduleTraitCor %>%
dplyr::rename("VOV_1" = "VOV-1", "ARV_2"= "ARV-2", "SV"= "SBV", "LSBV"= "LSV", "VDV1/DWVb"="DWVb")
class(moduleTraitCor)
moduleTraitCor %>%
as.data.frame() %>%
dplyr::rename("VOV_1" = "VOV-1", "ARV_2"= "ARV-2", "SV"= "SBV", "LSBV"= "LSV", "VDV1/DWVb"="DWVb")
moduleTraitCor %>%
as.data.frame() %>%
dplyr::rename("VOV-1" = "VOV_1", "ARV_2"= "ARV-2", "SV"= "SBV", "LSBV"= "LSV", "VDV1/DWVb"="DWVb")
moduleTraitCor_66 <- moduleTraitCor %>%
as.data.frame() %>%
dplyr::rename("VOV-1" = "VOV_1", "ARV-2"= "ARV_2", "SBV"= "SV", "LSV"= "LSBV", "DWVb"="VDV1/DWVb")
moduleTraitCor
moduleTraitCor_66 <- moduleTraitCor %>%
as.data.frame() %>%
dplyr::rename("VOV-1" = "VOV_1", "ARV-2"= "ARV_2", "SBV"= "SV", "DWVb"="VDV1/DWVb")
# before correlating, make the two dataframes into "matrices"
moduleTraitCor_66 <- moduleTraitCor %>%
as.data.frame() %>%
dplyr::rename("VOV-1" = "VOV_1", "ARV-2"= "ARV_2", "SBV"= "SV", "DWVb"="VDV1/DWVb") %>%
as.matrix()
moduleTraitPadjust_66 <- moduleTraitPadjust %>%
as.data.frame() %>%
dplyr::rename("VOV-1" = "VOV_1", "ARV-2"= "ARV_2", "SBV"= "SV", "DWVb"="VDV1/DWVb") %>%
as.matrix()
View(viruses_load_15)
MEs
viruses_load_15
class(viruses_load_15)
# change the names of the viruses to match their common name in the literature:
viruses_load_15 <- viruses_load_15 %>%
dplyr::rename("VOV-1" = "VOV_1", "ARV-2"= "ARV_2", "SBV"= "SV", "DWVb"="VDV1/DWVb")
viruses_load_15
# Define numbers of genes and samples
nGenes = ncol(for_modules);
nSamples = nrow(for_modules)
# Recalculate MEs with color labels
MEs0 = moduleEigengenes(for_modules, moduleColors)$eigengenes
MEs = orderMEs(MEs0)
# correlate the modules eigengenes (MEs) with the viral load (viruses_load_15)
moduleTraitCor = cor(MEs, viruses_load_15, use = "p");
moduleTraitPvalue = corPvalueStudent(moduleTraitCor, nSamples)
# first make the p-value matrix into a dataframe
moduleTraitPvalue_0 <- as.data.frame(moduleTraitPvalue)
# then "gather" all the p-values, so they will apear in one column
longer_Pvalue <- moduleTraitPvalue_0 %>%
rownames_to_column("module") %>%
gather("virus", "pvalue", -module)
# now calculate the p.adjust for each p-value
Padjust <- p.adjust(longer_Pvalue$pvalue, method = "fdr")
# and add the column of adjusted pvalues
Padjust <- add_column(longer_Pvalue, Padjust)
# now spread it back
moduleTraitPadjust <- Padjust %>%
dplyr::select(-pvalue) %>%
group_by(virus) %>%
pivot_wider(names_from = virus, values_from = Padjust)
moduleTraitPadjust <- column_to_rownames(moduleTraitPadjust, "module")
#  Display correlations and their adjusted p-values
textMatrix = paste(signif(moduleTraitCor_66, 2), "\n(",
signif(moduleTraitPadjust_66, 1), ")", sep = "");
dim(textMatrix) = dim(moduleTraitCor_66)
par(mar = c(6, 8.5, 3, 3));
# Display the correlation values within a heatmap plot
labeledHeatmap(Matrix = moduleTraitCor_66,
xLabels = names(viruses_load_15),
yLabels = names(MEs),
#xLabelsAngle = 90,
ySymbols = names(MEs),
colorLabels = FALSE,
colors = hcl.colors(n = 50, palette = "RdBu", alpha = NULL, rev = FALSE, fixup = TRUE),
invertColors = TRUE,
textMatrix = textMatrix,
setStdMargins = FALSE,
cex.text = 0.7,
zlim = c(-1,1),
main = paste("Varroa Module-viruses relationships"))
# save the matrices for next analyses
#save(moduleTraitCor_66,moduleTraitPadjust_66, file = "/Users/nuriteliash/Documents/GitHub/varroa-virus-networks/results/moduleTraitCor_66.RData")
#plot the correlation
sizeGrWindow(9, 5)
verboseScatterplot(x = corModulTrait_66, y = virusAbundCor_66, main = "Correlation between Fig 2a, \n virus-virus interaction; and Fig 2b, \n varroa-virus interaction", xlab = "Correlation of viral interaction \nwith varroa modules", ylab = "Correlation of viral abundance", abline = T, abline.color = "black", bg = "black", cex.lab = 1.2, cex.main = 1, cex.axis = 1)
